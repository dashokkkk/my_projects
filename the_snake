 Проект «Изгиб Питона»

 Классическая компьютерная игра «Змейка» является одной из самых известных в мире игр. Простые правила, минималистичный дизайн и драйв — причины популярности этой игры на протяжении многих лет: прототип был придуман в 1976 году, а первая «Змейка», которую мы знаем, — в 1995-м.
 Суть игры заключается в том, что игрок управляет змейкой, которая движется по игровому полю, разделённому на клетки.
 Цель игры — увеличивать длину змейки, «съедая» появляющиеся на экране яблоки (часто изображаемые в виде точек или других символов).

Правила игры

Змейка состоит из сегментов.
Змейка движется в одном из четырёх направлений — вверх, вниз, влево или вправо. Игрок управляет направлением движения, но змейка не может остановиться или двигаться назад.
Каждый раз, когда змейка съедает яблоко, она увеличивается в длину на один сегмент.
В классической версии игры столкновение змейки с границей игрового поля приводит к проигрышу. Однако в некоторых вариациях змейка может проходить сквозь одну стену и появляться с противоположной стороны поля. У вас будет именно так.
Если змейка столкнётся сама с собой — игра начинается с начала.
Общая логика и компоненты игры

Игровое поле — это прямоугольник чёрного цвета размером 640 на 480 точек, разделённый на ячейки.
Ячейка — это квадрат размером 20 на 20 точек. Таким образом, игровое поле имеет размер 32 ячейки по горизонтали и 24 по вертикали. 
У каждой ячейки есть координаты. Отсчёт координат начинается с левого верхнего угла игрового поля. Самая первая ячейка — это ячейка с координатами 0, 0. Координаты каждой ячейки определяются координатами её верхнего левого угла.
Змейка и яблоко — это объекты, которые создаются и отрисовываются на игровом поле.
Яблоко — это просто квадрат размером в одну ячейку игрового поля. При создании яблока координаты для него определяются случайным образом и сохраняются до тех пор, пока змейка не «съест» яблоко. После этого для яблока вновь задаются случайные координаты.
Змейка изначально состоит из одной головы — из одной ячейки на игровом поле. Змейка постоянно куда-то ползёт и после того, как «съест» яблоко, вырастает на один сегмент. При запуске игры змейка сразу же начинает движение вправо по игровому полю.
Описать змейку проще всего списком, в котором каждый элемент — это сегмент змейки. Значение элемента списка — это координаты сегмента на игровом поле.
Координаты удобно представить через кортеж. При размере ячейки 20×20:
У яблока могут быть координаты, например, (40, 340).
Змейка, состоящая только из одной головы, может быть представлена списком [(20, 240)]. Если змейка состоит из двух сегментов, она может быть описана списком [(20, 240), (40, 240)].
Отрисовать яблоко на игровом поле — нарисовать квадрат, залитый цветом, размером в одну ячейку по указанным координатам.
Отрисовать змейку — означает отрисовать столько квадратов, сколько элементов есть в списке с координатами.

Изменить положение змейки на одну ячейку — означает вставить в начало списка новый элемент с новыми координатами головы и удалить последний элемент списка.
Событие «змейка съела яблоко» — состояние, когда координаты головы змейки совпали с координатами яблока.
Код игры состоит из нескольких основных частей:
Инициализация Pygame и настройка игрового окна. В начале программы настраиваются основные параметры игры, такие как размеры окна и цвет фона. Создаётся окно игры с заданными размерами, устанавливается заголовок окна.
Классы игровых объектов: 
GameObject — это базовый класс, от которого наследуются другие игровые объекты. Он содержит общие атрибуты игровых объектов — например, эти атрибуты описывают позицию и цвет объекта. Этот же класс содержит и заготовку метода для отрисовки объекта на игровом поле — draw.
Snake — класс, унаследованный от GameObject, описывающий змейку и её поведение. Этот класс управляет её движением, отрисовкой, а также обрабатывает действия пользователя.
Apple — класс, унаследованный от GameObject, описывающий яблоко и действия с ним. Яблоко должно отображаться в случайных клетках игрового поля.
Логика игры: 
Сначала создаются необходимые объекты.
В основном цикле игры (в функции main) происходит обновление состояний объектов: змейка обрабатывает нажатия клавиш и двигается в соответствии с выбранным направлением. Если змейка съедает яблоко, её размер увеличивается на один сегмент, а яблоко перемещается на новую случайную позицию.
При столкновении змейки с самой собой игра начинается заново.
Отрисовка объектов. В каждой итерации цикла змейка меняет своё положение на игровом поле на одну ячейку. По факту это означает, что в списке координат, описывающем змейку, добавляется новый элемент (новая голова в начале списка с новыми координатами) и удаляется последний. Координаты для нового элемента определяются в зависимости от направления движения.  После удаления координат хвостового сегмента из списка, описывающего змейку, ячейка, с которой она «уползла», останется закрашена в цвет змейки. После отрисовки змейки по обновлённым координатам следует «затирать её след» — то есть отрисовывать чёрный (по цвету игрового поля) квадрат по координатам удалённого последнего сегмента. 
Обновление экрана. На каждой итерации цикла while программа вычисляет новое состояние игрового поля: определяет координаты каждого сегмента змейки и, при необходимости, координаты яблока, а также проверяет, не столкнулась ли змейка сама с собой. После выполнения всех вычислений вызывается функция pygame.display.update(), которая обновляет игровое поле на экране пользователя. Отображение игрового поля обновляется на каждой итерации цикла.  Однако, если программа будет отрисовывать изменения игрового поля с той скоростью, на которую способен компьютер, змейка будет перемещаться по экрану столь быстро, что игрок не сможет ей управлять.   Чтобы замедлить «течение событий», в Pygame применяется метод clock.tick(N): он изменяет выполнение кода так, что итерации цикла будут выполняться не чаще чем N раз в секунду. В прекоде метод clock.tick() вызван с аргументом 20, это означает, что положение змейки на экране будет изменяться не более 20 раз в секунду.
Игра продолжается в бесконечном цикле, пока пользователь не закроет окно.
Классы и методы

Класс GameObject:
Атрибуты:
position — позиция объекта на игровом поле. В данном случае она инициализируется как центральная точка экрана.
body_color — цвет объекта. Он не задаётся конкретно в классе GameObject, но предполагается, что будет определён в дочерних классах.
Методы:
__init__ — инициализирует базовые атрибуты объекта, такие как его позиция и цвет.
draw — это абстрактный метод, который предназначен для переопределения в дочерних классах. Этот метод должен определять, как объект будет отрисовываться на экране. По умолчанию — pass.
Класс Apple, наследуется от GameObject:
Атрибуты:
body_color — цвет яблока. В данном случае задаётся RGB-значением (красный цвет — (255, 0, 0)).
position — позиция яблока на игровом поле. Яблоко появляется в случайном месте на игровом поле.
Методы:
__init__ — задаёт цвет яблока и вызывает метод randomize_position, чтобы установить начальную позицию яблока.
randomize_position — устанавливает случайное положение яблока на игровом поле — задаёт атрибуту position новое значение. Координаты выбираются так, чтобы яблоко оказалось в пределах игрового поля.
draw — отрисовывает яблоко на игровой поверхности (есть в прекоде).
Класс Snake, наследуется от GameObject:
Программно змейка — это список координат, каждый элемент списка соответствует отдельному сегменту тела змейки. Атрибуты и методы класса обеспечивают логику движения, отрисовку, обработку событий (нажата клавиша) и другие аспекты поведения змейки в игре.
Атрибуты:
length — длина змейки. Изначально змейка имеет длину 1.
positions — список, содержащий позиции всех сегментов тела змейки. Начальная позиция — центр экрана.
direction — направление движения змейки. По умолчанию змейка движется вправо.
next_direction — следующее направление движения, которое будет применено после обработки нажатия клавиши. По умолчанию задать None.
body_color — цвет змейки. Задаётся RGB-значением (по умолчанию — зелёный: (0, 255, 0)).
Методы:
__init__ — инициализирует начальное состояние змейки.
update_direction — обновляет направление движения змейки (есть в прекоде).
move — обновляет позицию змейки (координаты каждой секции), добавляя новую голову в начало списка positions и удаляя последний элемент, если длина змейки не увеличилась.
draw — отрисовывает змейку на экране, затирая след (есть в прекоде).
get_head_position — возвращает позицию головы змейки (первый элемент в списке positions).
reset — сбрасывает змейку в начальное состояние.
Функции

handle_keys — обрабатывает нажатия клавиш, чтобы изменить направление движения змейки (есть в прекоде).
Основной игровой цикл

Создание экземпляров классов Snake и Apple до цикла.
В бесконечном цикле: 
Обрабатывайте события клавиш при помощи функции handle_keys().
Обновляйте направление движения змейки при помощи метода update_direction().
Двигайте змейку (модифицируйте список) при помощи метода move().
Проверяйте, съела ли змейка яблоко (если да, увеличьте длину змейки и переместите яблоко).
Проверяйте столкновения змейки с собой (если столкновение, сброс игры при помощи метода reset()).
Отрисовывайте змейку и яблоко, используя соответствующие методы draw.
Обновляйте экран при помощи метода pygame.display.update().
Задание

Напишите классы GameObject, Apple и Snake, а также их атрибуты и методы.
Допишите основной цикл игры в функции main().
Всё, к чему можно написать докстринги, должно содержать докстринги.
Код должен соответствовать PEP 8.


from random import randint, choice 
 
import pygame as pg 
 
SCREEN_WIDTH, SCREEN_HEIGHT = 640, 480 
GRID_SIZE = 20 
GRID_WIDTH = SCREEN_WIDTH // GRID_SIZE 
GRID_HEIGHT = SCREEN_HEIGHT // GRID_SIZE 
 
UP = (0, -1) 
DOWN = (0, 1) 
LEFT = (-1, 0) 
RIGHT = (1, 0) 
DIRECTION_LIST = [UP, DOWN, LEFT, RIGHT] 
 
BOARD_BACKGROUND_COLOR = (0, 0, 0) 
 
BORDER_COLOR = (93, 216, 228) 
 
APPLE_COLOR = (255, 0, 0) 
 
SNAKE_COLOR = (0, 255, 0) 
 
SPEED = 20 
 
screen = pg.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), 0, 32) 
 
pg.display.set_caption('Змейка') 
 
clock = pg.time.Clock() 
 
 
class GameObject: 
    """Базовый класс, от которого наследуются другие игровые объекты""" 
 
    def __init__(self) -> None: 
        self.body_color = None 
        self.position = ((SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)) 
 
    def draw(self): 
        """Метод отрисовки объекта на игровом поле""" 
        pass 
 
    def draw_cell(self, position, screen, body_color, border_color): 
        """Метод отрисовки одной ячейки объекта""" 
        rect = pg.Rect(position, (GRID_SIZE, GRID_SIZE)) 
        pg.draw.rect(screen, body_color, rect) 
        pg.draw.rect(screen, border_color, rect, 1) 
 
 
class Snake(GameObject): 
    """Класс, унаследованный от GameObject, описывающий змейку""" 
 
    def __init__(self): 
        super().__init__() 
        self.body_color = SNAKE_COLOR 
        self.reset() 
        self.direction = RIGHT 
 
    def update_direction(self): 
        """Функция обновления направления движения змейки""" 
        if self.next_direction: 
            self.direction = self.next_direction 
            self.next_direction = None 
 
    def move(self): 
        """Функция обновления позиции змейки""" 
        first_x, first_y = self.get_head_position() 
        second_x, second_y = self.direction 
        self.position = ((first_x + (second_x * GRID_SIZE)) % SCREEN_WIDTH, 
                         (first_y + (second_y * GRID_SIZE)) % SCREEN_HEIGHT) 
        self.positions.insert(0, (self.position)) 
        if len(self.positions) - 1 > self.length: 
            self.last = self.positions.pop() 
        else: 
            self.last = None 
 
    def get_head_position(self): 
        """Функция получения позиции головы змейки""" 
        return self.positions[0] 
 
    def reset(self): 
        """Функция сброса змейки в начальное состояние""" 
        self.length = 1 
        self.positions = [(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)] 
        self.direction = choice(DIRECTION_LIST) 
        self.next_direction = None 
        self.last = None 
 
    def draw(self): 
        """Отрисовка змейки""" 
        for position in self.positions[:-1]: 
            self.draw_cell(position, screen, self.body_color, BORDER_COLOR) 
        if self.last: 
            last_rect = pg.Rect(self.last, (GRID_SIZE, GRID_SIZE)) 
            pg.draw.rect(screen, BOARD_BACKGROUND_COLOR, last_rect) 
 
 
def handle_keys(game_object): 
    """Функция обработки действий пользователя""" 
    for event in pg.event.get(): 
        if event.type == pg.QUIT: 
            pg.quit() 
            raise SystemExit 
        elif event.type == pg.KEYDOWN: 
            if event.key == pg.K_UP and game_object.direction != DOWN: 
                game_object.next_direction = UP 
            elif event.key == pg.K_DOWN and game_object.direction != UP: 
                game_object.next_direction = DOWN 
            elif event.key == pg.K_LEFT and game_object.direction != RIGHT: 
                game_object.next_direction = LEFT 
            elif event.key == pg.K_RIGHT and game_object.direction != LEFT: 
                game_object.next_direction = RIGHT 
 
 
class Apple(GameObject): 
    """Класс, унаследованный от GameObject, описывающий яблоко""" 
 
    def __init__(self, snake_positions=()): 
        super().__init__() 
        self.body_color = APPLE_COLOR 
        self.position = self.randomize_position(snake_positions) 
 
    def draw(self): 
        """Отрисовка яблока""" 
        self.draw_cell(self.position, screen, self.body_color, BORDER_COLOR) 
 
    def randomize_position(self, snake_positions=()): 
        """Функция, устанавливающая случайное положение яблока""" 
        while True: 
            while self.position in snake_positions: 
                rand_x = randint(0, 
                                 (SCREEN_WIDTH // GRID_SIZE) - 1) * GRID_SIZE 
                rand_y = randint(0, 
                                 (SCREEN_HEIGHT // GRID_SIZE) - 1) * GRID_SIZE 
                self.position = (rand_x, rand_y) 
            return self.position 
 
 
def main(): 
    """Функция, описывающая основную логику игры""" 
    pg.init() 
    apple = Apple() 
    snake = Snake() 
    apple.randomize_position(snake.positions) 
    while True: 
        clock.tick(SPEED) 
        screen.fill(BOARD_BACKGROUND_COLOR) 
        apple.draw() 
        snake.draw() 
        handle_keys(snake) 
        snake.update_direction() 
        snake.move() 
        if snake.get_head_position() in snake.positions[4:]: 
            snake.reset() 
            screen.fill(BOARD_BACKGROUND_COLOR) 
        elif apple.position == snake.get_head_position(): 
            snake.length += 1 
            apple.randomize_position(snake.positions) 
        pg.display.update() 
 
 
if __name__ == '__main__': 
    main() 

